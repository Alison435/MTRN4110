
//////////////////////////////////

//PUT SERIAL MONITOR IN NEWLINE MODE

//MUST PRESS ENTER AFTER EACH INPUT

//////////////////////////////////

#define ROWS_wall 5
#define COLS_wall 9
#define H_size (ROWS_wall+1)*COLS_wall  //54
#define V_size ROWS_wall*(COLS_wall+1) //50
#define NORTH 0
#define EAST 1
#define SOUTH 2
#define WEST 3

//MAZE STUFF
/////////////
//
//int horizontalWalls[ROWS_wall+1][COLS_wall];
//int verticalWalls[ROWS_wall][COLS_wall+1];


// vertical walls array
  int verticalWalls[ROWS_wall][COLS_wall + 1] = { {1,0,0,0,1,0,0,0,0,1}, 
                                                  {1,1,1,0,0,1,0,1,1,1}, 
                                                  {1,0,0,1,0,0,1,1,1,1}, 
                                                  {1,0,0,0,1,0,0,0,0,1}, 
                                                  {1,0,1,0,0,0,1,0,1,1}, 
                                                                };
                                     //verticalWalls[5][10]
                                                                                  
  // horizontal walls array                                                 
  int horizontalWalls[ROWS_wall + 1][COLS_wall]  = { {1,1,1,1,1,1,1,1,1}, 
                                                     {0,0,1,1,0,1,1,0,0}, 
                                                     {0,1,0,1,1,1,0,0,1},
                                                     {1,0,1,1,0,1,0,0,0},
                                                     {0,1,0,1,0,1,0,1,0},
                                                     {1,1,1,1,1,1,1,1,1}
                                                    
                                                     };            //horizontalWalls[6][9]
                                                     
/*
// vertical walls array
  int verticalWalls[ROWS_wall][COLS_wall + 1] = { {1,0,2,0,1,0,0,0,0,1}, 
                                                  {1,0,2,0,1,0,0,0,0,1}, 
                                                  {1,0,2,0,1,0,0,0,0,1}, 
                                                  {1,0,2,0,1,0,0,0,0,1}, 
                                                  {1,0,2,0,1,0,0,0,0,1}, 
                                                                };
                                     //verticalWalls[5][10]
                                     
                                                                                  
  // horizontal walls array                                                 
  int horizontalWalls[ROWS_wall + 1][COLS_wall]  = { {1,1,1,1,1,1,1,1,1}, 
                                                     {1,1,1,1,1,1,1,1,1}, 
                                                     {0,0,0,0,0,0,0,0,0},
                                                     {2,2,2,2,2,2,2,2,2},
                                                     {1,1,1,1,1,1,1,1,1},
                                                     {1,1,1,1,1,1,1,1,1}
                                                    
                                                     };            //horizontalWalls[6][9]
*/

                       

//Mouse Stuff  
int mouseSRow;
int mouseSColumn;
int mouseHeading;

//Store values from flood fill
int values[ROWS_wall][COLS_wall];

//ONLY FOR 3X3 MAZE FOR NOW

int goalRow = 2;
int goalCol = 4;

//Maximum value is the goal value
int Max_Value_Goal;



int x = 0;

///STORING VALUES STUFF FROM SERIAL INPUT
//////////////
//arrays to store stuff in
int array_H[H_size];
int array_V[V_size];

//var from serial
unsigned int integerValue=0;  // Max value is 65535
char incomingByte;

int h = 0;
int v = 0;


////////////////////////////////////
//Function Declarations
void Print_Maze();
void Get_Maze_Layout();
void Get_Robot_Pos();
void Get_Start();
void Get_Dir();
void flood_fill();
void print_value();
/////////////////////////////

                                                   
void setup() {


  //Setup Serial
  Serial.begin(9600);
  //Serial1.begin(9600);

  //GOOD
  //get maze layout
  //Get_Maze_Layout();
  
  //GOOD
  //get intial mouse direction
  Get_Dir();
  
  //GOOD
  //get initial starting position
  Get_Start();

  //GOOD
  //carry out flood fill on maze
  flood_fill();

  //print maze
  Print_Maze();

  //print rest of flood value
  //print_rest();

}

///////////////////////////////////
//Function Definitions
///////////////////////////////////

//get maze layout
void Get_Maze_Layout(){
  
  //Start storing horizontal array
  Serial.print("Please enter 54 values for array_H from top to bottom and left to right\n");
  while(h<H_size){
      if (Serial.available() > 0) {   // something came across serial
        integerValue = 0;         // throw away previous integerValue
        while(1) {            // force into a loop until 'n' is received
          incomingByte = Serial.read();
          if (incomingByte == '\n') break;   // exit the while(1), we're done receiving
          if (incomingByte == '\r') break;   // exit the while(1), we're done receiving
          if (incomingByte == -1) continue;  // if no characters are in the buffer read() returns -1
          integerValue *= 10;  // shift left 1 decimal place
          // convert ASCII to integer, add, and shift left 1 decimal place
          integerValue = ((incomingByte - 48) + integerValue);
        }
        array_H[h] = integerValue;  
        h++;
    }
  }

  //Start storing vertical array
  Serial.print("Please enter 50 values for array_V from top to bottom and left to right\n");
  while(v<V_size){
      if (Serial.available() > 0) {   // something came across serial
        integerValue = 0;         // throw away previous integerValue
        while(1) {            // force into a loop until 'n' is received
          incomingByte = Serial.read();
          if (incomingByte == '\n') break;   // exit the while(1), we're done receiving
          if (incomingByte == '\r') break;   // exit the while(1), we're done receiving
          if (incomingByte == -1) continue;  // if no characters are in the buffer read() returns -1
          integerValue *= 10;  // shift left 1 decimal place
          // convert ASCII to integer, add, and shift left 1 decimal place
          integerValue = ((incomingByte - 48) + integerValue);
        }
        array_V[v] = integerValue;  
        v++;
    }
  }

///////////////////////////////////////
//
//  Serial.print("The array string entered for Horizontal array is ");
//  //Print array contents
//  //print array_H
//  h = 0 ;
//  while(h< H_size){
//      Serial.print(bool(array_H[h]));  
//      h++;
//  }
//  
//  Serial.print("\n");
//
//  Serial.print("The array string entered for Vertical array is ");
//  //print array_V
//  v = 0 ;
//  while(v<V_size){
//      Serial.print(bool(array_V[v]));  
//      v++;
//  }
//
//  Serial.print("\n");
//
///////////////////////////////////////


////Convert array to suitable size array
////store values

      //horizontal
      for(int row = 0; row < ROWS_wall+1; row++){
        for(int col = 0; col < COLS_wall; col++){
          if(x != H_size){
            horizontalWalls[row][col] = array_H[x++];
          }
        }
      }
      x=0;
      //vertical
      for(int row = 0; row < ROWS_wall; row++){
        for(int col = 0; col < COLS_wall + 1; col++){
          if(x != V_size){
            verticalWalls[row][col] = array_V[x++];
          }
        }
      }

}

//Printing the Maze
void Print_Maze(){
    //start by checking the goal
//    int CurrRowCheck = goalRow;
//    int CurrColCheck = goalCol;
//    int prevRow = goalRow;
//    int prevCol = goalCol;

int CurrRowCheck = 2;
int CurrColCheck = 4;
//
////keep track of the column and row of every two cells 
int prevRow = 2;
int prevCol = 4;
           
           for(int i = 0;i < 2*ROWS_wall+1;i++)
           {
                Serial.print(CurrRowCheck); Serial.print(" ");
                Serial.print(CurrColCheck); Serial.print(" ");
                Serial.print(prevRow); Serial.print(" ");
                Serial.print(prevCol); Serial.print(" ");

            
            for(int j = 0;j < 2*COLS_wall+1;j++)
            {
                //Add Horizontal Walls
                if(i%2 == 0 && j%2 == 1)
                {
                    if(horizontalWalls[i/2][j/2] == true)
                    {
                        Serial.print(" -----");
                    } else if(horizontalWalls[i/2][j/2] == 2){
                         Serial.print(" *****");
                    }
                    else
                    {
                        Serial.print("      ");
                    }
                }

                //Add Vertical Walls
                if(i%2 == 1 && j%2 == 0)
                {
                    if(verticalWalls[i/2][j/2] == true)
                    {      
                            Serial.print("|  ");
                        }else if(verticalWalls[i/2][j/2] == 2){
                                Serial.print("*  ");
                        }
                        else
                        {
                            Serial.print("   ");                    
                    }
            }

             //Add Flood Fill Values
                if(i%2 == 1 && j%2== 1){
                    if((i-1)/2 == mouseSRow && (j-1)/2 == mouseSColumn)
                    {
                        if(mouseHeading == NORTH)
                        {
                            Serial.print(" N ");
                        }
                        else if(mouseHeading == EAST)
                        {
                            Serial.print(" E ");
                        }
                        else if(mouseHeading == SOUTH)
                        {
                            Serial.print(" S ");
                        }
                        else if(mouseHeading == WEST)
                        {
                            Serial.print(" W ");
                        }
                    }
                    else
                    {

                      /////////////////
                        //represents the current cell the for loops are checking
                        int value = values[(i-1)/2][(j-1)/2]; 

                         
                        
                         
                        if(value <= Max_Value_Goal){
                            if(((i-1)/2) == CurrRowCheck && ((j-1)/2) == CurrColCheck){

                              //CurrRowCheck = CurrRowCheck + 1;
                                
//                                //check NORTH
//                                //only check if the walls or not there
//                                if(horizontalWalls[CurrRowCheck][CurrColCheck] == 0){
//                                    //check if the north
//                                    if(values[CurrRowCheck-1][CurrColCheck] == value - 1 ){
//                                        //if there is a value ones less in the WEST OR EAST
//                                        if((values[CurrRowCheck][CurrColCheck - 1] == value - 1 ) || (values[CurrRowCheck][CurrColCheck + 1] == value - 1) ){
//                                            if(CurrColCheck = prevCol){
//                                                //change Current Row and Column being checked
//                                                CurrRowCheck = CurrRowCheck - 1;
//                                                CurrColCheck = CurrColCheck;
//                                            } else {
//                                                if(values[((i-1)/2)][((j-1)/2)] < 10){
//                                                    Serial.print(" ");
//                                                    Serial.print("  ");                                  
//                                                } else {
//                                                    Serial.print("  ");
//                                                    Serial.print(" ");                                  
//                                                }                                                
//                                            }
//
//                                        
//                                        }
//                                      
//                                    }
//                                }
//
//                                //check EAST
//                                if(verticalWalls[CurrRowCheck][CurrColCheck + 1] == 0){
//                                    if(values[CurrRowCheck][CurrColCheck + 1] == value - 1 ){
//                                        if((values[CurrRowCheck + 1][CurrColCheck] == value - 1 ) || (values[CurrRowCheck - 1][CurrColCheck] == value - 1) ){
//                                            if(CurrRowCheck = prevRow){                             
//                                                //change Current Row and Column being checked
//                                                CurrRowCheck = CurrRowCheck;
//                                                CurrColCheck = CurrColCheck + 1;
//                                            } else {
//                                                if(values[((i-1)/2)][((j-1)/2)] < 10){
//                                                    Serial.print(" ");
//                                                    Serial.print("  ");                                  
//                                                } else {
//                                                    Serial.print("  ");
//                                                    Serial.print(" ");                                  
//                                                }                                                
//                                            }
//                                        }
//                                    }
//
                                //check SOUTH
                                if(horizontalWalls[CurrRowCheck + 1][CurrColCheck] == 0){
                                    if(values[CurrRowCheck + 1][CurrColCheck] == value - 1 ){
                                      
//                                        if((values[CurrRowCheck][CurrColCheck - 1] == value - 1 ) || (values[CurrRowCheck][CurrColCheck + 1] == value - 1) ){
//                                            if(CurrColCheck = prevCol){
//                                                //change Current Row and Column being checked
//                                                CurrRowCheck = CurrRowCheck + 1;
//                                                CurrColCheck = CurrColCheck;                                              
//                                            }else {
//                                                if(values[((i-1)/2)][((j-1)/2)] < 10){
//                                                    Serial.print(" ");
//                                                    Serial.print("  ");                                  
//                                                } else {
//                                                    Serial.print("  ");
//                                                    Serial.print(" ");                                  
//                                                }                                               
//                                            }
//                                        }

                                                CurrRowCheck = CurrRowCheck + 1;
                                                CurrColCheck = CurrColCheck;
                                    }
                                }                           


                                //check WEST
                                if(verticalWalls[CurrRowCheck][CurrColCheck] == 0){
                                    if(values[CurrRowCheck][CurrColCheck - 1] == value - 1 ){

                                    
//                                        if((values[CurrRowCheck + 1][CurrColCheck] == value - 1 ) || (values[CurrRowCheck - 1][CurrColCheck] == value - 1) ){
//                                            if(CurrRowCheck = prevRow){                             
//                                                //change Current Row and Column being checked
//                                                CurrRowCheck = CurrRowCheck;
//                                                CurrColCheck = CurrColCheck - 1;
//                                            } else {
//                                                if(values[((i-1)/2)][((j-1)/2)] < 10){
//                                                    Serial.print(" ");
//                                                    Serial.print("  ");                                  
//                                                } else {
//                                                    Serial.print("  ");
//                                                    Serial.print(" ");                                  
//                                                }                                                
//                                            }
//                                        }

                                                CurrRowCheck = CurrRowCheck;
                                                CurrColCheck = CurrColCheck - 1;
                                        
                                    }                   
                                }

                              
                             //   }
                                
                                //print value
                                if(values[((i-1)/2)][((j-1)/2)] < 10){
                                    Serial.print(value);
                                    Serial.print("  ");                                  
                                } else {
                                    Serial.print(value);
                                    Serial.print(" ");                                  
                                }     


                                
                                                                                          
                            } else {

                             //Serial.print("i");
                                if(values[((i-1)/2)][((j-1)/2)] < 10){
                                    Serial.print(" ");
                                    Serial.print("  ");                                  
                                } else {
                                    Serial.print("  ");
                                    Serial.print(" ");                                  
                                }      
                            }
                            
                            prevRow  = CurrRowCheck;
                            prevCol  = CurrColCheck;

                            

                        }  else {
                                if(values[((i-1)/2)][((j-1)/2)] < 10){
                                    Serial.print(" ");
                                    Serial.print("  ");                                  
                                } else {
                                    Serial.print("  ");
                                    Serial.print(" ");                                  
                                }                          
                        }

                    }          
                                                          
                }
                             
            }
             Serial.print("\n");
             
        }
        Serial.print("\n");
        
    }


/////////////////////////////////////

void Get_Dir(){
  Serial.print("Please enter starting direction of mouse (N:0, E:1, S:2, W:3)\n");

  int direction;
  h=0;
  while(h<1){
      if (Serial.available() > 0) {   // something came across serial
        integerValue = 0;         // throw away previous integerValue
        while(1) {            // force into a loop until 'n' is received
          incomingByte = Serial.read();
          if (incomingByte == '\n') break;   // exit the while(1), we're done receiving
          if (incomingByte == '\r') break;   // exit the while(1), we're done receiving
          if (incomingByte == -1) continue;  // if no characters are in the buffer read() returns -1
          integerValue *= 10;  // shift left 1 decimal place
          // convert ASCII to integer, add, and shift left 1 decimal place
          integerValue = ((incomingByte - 48) + integerValue);
        }
        direction = integerValue;  
        h++;
    }
    if(direction == 0){
        mouseHeading = NORTH;
    } else if(direction == 1){
        mouseHeading = EAST;
    } else if(direction == 2){
        mouseHeading = SOUTH;
    } else if(direction == 3){
        mouseHeading = WEST;
    }
  }

  //Serial.print(mouseHeading);
}

void Get_Start(){
  
//    //Enter the row position of mouse
  Serial.print("Please enter start row position of mouse\n");
  h=0;
  while(h<1){
      if (Serial.available() > 0) {   // something came across serial
        integerValue = 0;         // throw away previous integerValue
        while(1) {            // force into a loop until 'n' is received
          incomingByte = Serial.read();
          if (incomingByte == '\n') break;   // exit the while(1), we're done receiving
          if (incomingByte == '\r') break;   // exit the while(1), we're done receiving
          if (incomingByte == -1) continue;  // if no characters are in the buffer read() returns -1
          integerValue *= 10;  // shift left 1 decimal place
          // convert ASCII to integer, add, and shift left 1 decimal place
          integerValue = ((incomingByte - 48) + integerValue);
        }
        mouseSRow = integerValue;  
        h++;
    }
  }

    //Enter the column position of mouse
  Serial.print("Please enter start column position of mouse\n");
  h=0;
  while(h<1){
      if (Serial.available() > 0) {   // something came across serial
        integerValue = 0;         // throw away previous integerValue
        while(1) {            // force into a loop until 'n' is received
          incomingByte = Serial.read();
          if (incomingByte == '\n') break;   // exit the while(1), we're done receiving
          if (incomingByte == '\r') break;   // exit the while(1), we're done receiving
          if (incomingByte == -1) continue;  // if no characters are in the buffer read() returns -1
          integerValue *= 10;  // shift left 1 decimal place
          // convert ASCII to integer, add, and shift left 1 decimal place
          integerValue = ((incomingByte - 48) + integerValue);
        }
        mouseSColumn = integerValue;  
        h++;
    }
  }
  //Serial.print(mouseSRow);
  //Serial.print(mouseSColumn);

}

void flood_fill(){
  //start from mouse start postion then flood
  int row = 0 ;
  int col = 0;
  int mazeValueChanged = 1;
  int CurrentExploredValue = 0;
  int N = (ROWS_wall*COLS_wall)-1;
  
  //set all cell values to 8 (unexplored)
  //Set start cell to 0
  for(int row = 0;row < ROWS_wall; row++){
    for(int col = 0; col < COLS_wall; col++){
       if(row == mouseSRow && col == mouseSColumn){
         values[mouseSRow][mouseSColumn] = 0;
       }else {
         values[row][col] = N;
       }
    }
  }
 
//  //Do floodfill
  while(mazeValueChanged != 0){
    mazeValueChanged = 0;
    for(int FloodR = 0; FloodR < ROWS_wall; FloodR++){
        for(int FloodC = 0; FloodC < COLS_wall; FloodC++){
            if(values[FloodR][FloodC] == CurrentExploredValue){
                //check NORTH
                if(horizontalWalls[FloodR][FloodC] == 0){
                    if(values[FloodR-1][FloodC] == N){
                        values[FloodR-1][FloodC] = values[FloodR][FloodC] + 1;
                        mazeValueChanged = 1;
                    }
                }
                
                if(verticalWalls[FloodR][FloodC+1] == 0){ //check EAST
                    if(values[FloodR][FloodC+1] == N){
                        values[FloodR][FloodC+1] = values[FloodR][FloodC]+1;
                        mazeValueChanged = 1;
                    }
                }
                
                if(horizontalWalls[FloodR+1][FloodC] == 0){ //checl SOUTH
                    if(values[FloodR+1][FloodC] == N){
                        values[FloodR+1][FloodC] = values[FloodR][FloodC]+1;
                        mazeValueChanged = 1;
                    }
                }
                
                if(verticalWalls[FloodR][FloodC] == 0){ //check WEST
                    if(values[FloodR][FloodC-1] == N){
                        values[FloodR][FloodC-1] = values[FloodR][FloodC]+1;
                        mazeValueChanged = 1;                 
                    }
                }
                
            }
            
        }
    }
    CurrentExploredValue += 1;
  }

  //Store value of goal
  Max_Value_Goal = values[goalRow][goalCol];


//////////////////////////
//testing
//print contents of values array

 for(int row = 0;row < ROWS_wall; row++){
    for(int col = 0; col < COLS_wall; col++){
         Serial.print(values[row][col]);
    }
 } 

//Print CurrentExploredValue at end
    Serial.print("\n");
//  Serial.print( CurrentExploredValue);
//  Serial.print("\n");


//Print value of goal
//  Serial.print(Max_Value_Goal);
//  Serial.print("\n"); 
///////////////////////////////

}




void loop() {
}